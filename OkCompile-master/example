%{
  package jSHLang;

  import java.io.*;
  import java.util.ArrayList;
%}

%token <EVal> PROGRAM_KW MAIN_KW PROCEDURE_KW INTEGER_KW REAL_KW CHAR_KW BOOLEAN_KW IF_KW THEN_KW ELSE_KW DO_KW WHILE_KW FOR_KW IN_KW REPEAT_KW SWITCH_KW CASE_KW DEFAULT_KW END_KW RETURN_KW EXIT_KW WHEN_KW AND_KW AND_THEN_KW OR_KW OR_ELSE_KW NOT_KW SEMICOLON_KW COLON_KW COMMA_KW ASS_KW LP_KW RP_KW LB_KW RB_KW LCB_KW RCB_KW TWO_DOTS_KW EQ_KW NE_KW LE_KW LT_KW GE_KW GT_KW ADD_KW SUB_KW MUL_KW DIV_KW MOD_KW

%token <EVal> IDENTIFIER
%type <EVal> saved_identifier
%token <EVal> INTEGER_CONSTANT
%type <EVal> saved_integer
%token <EVal> REAL_CONSTANT
%type <EVal> saved_real
%token <EVal> CHAR_CONSTANT
%type <EVal> saved_char
%token <EVal> BOOLEAN_CONSTANT
%type <EVal> saved_boolean

%type <EVal> type_specifiers declarator_list declarator declarator_end dec initializer initializer_end initializer_list initializer_list_in_cb initer range block statement_list statement matched unmatched other_statement caseelement default expressions constant_expressions bool_expressions arithmatic_expressions
%type <EVal> M N

%code {

	public static final String TYPE_STRING_INTEGER = "int";
	public static final String TYPE_STRING_REAL = "double";
	public static final String TYPE_STRING_CHAR = "char";
	public static final String TYPE_STRING_BOOLEAN = "int";

	private static final String tempStr = "__SHLangTempVar";
	public static final String startStr = "__SHLangStartVar";
	public static final String sizeStr = "__SHLangSizeVar";
	public static final String indexStr = "__SHLangIndexVar";
	public static final String condStr = "__SHLangConditionVar";

	public static String lexIdentifier;
	public static int lexInt;
	public static double lexReal;
	public static boolean lexBoolean;
	public static char lexChar;

	private ArrayList<Quadruple> quadruples = new ArrayList<>();
	private SymbolTable symbolTable = new SymbolTable();
	public static PrintStream writer;

	private int tempCounter = 0;

	public String fileAddress;

	public static void main(String args[]) throws IOException {
        YYParser yyparser;
        final Yylex lexer;

        String inputCode = ".\\files\\Code.shl";
        String outputCode = "E:\\Dev C++\\TEMP - Programs\\compiler.c";
        String output = "output.txt";

        if (args.length == 1) {
            inputCode = args[0];
            outputCode = args[0] + ".c";
            output = args[0] + ".txt";
        }
        if (args.length == 2) {
            inputCode = args[0];
            outputCode = args[1];
            output = args[0] + ".txt";
        }
        if (args.length == 3) {
            inputCode = args[0];
            outputCode = args[1];
            output = args[2];
        }

        writer = new PrintStream(new File(output));
        lexer = new Yylex(new InputStreamReader(new FileInputStream(inputCode)));

        yyparser = new YYParser(new Lexer() {

            @Override
            public int yylex() {
                int yyl_return = -1;
                try {
                    yyl_return = lexer.yylex();
                } catch (IOException e) {
                    System.err.println("IO error: " + e);
                }
                return yyl_return;
            }

            @Override
            public void yyerror(String error) {
                System.err.println("Error! " + error);
            }

            @Override
            public Object getLVal() {
                return null;
            }
        });
        yyparser.fileAddress = outputCode;
        yyparser.parse();

        return;
	}

	private void emit(String operation, String arg0, String arg1, String result) {
		quadruples.add(new Quadruple(operation, arg0, arg1, result));
	}

	private void backpatch(ArrayList<Integer> list, int quadNumber) {
		for (int i = 0; i < list.size(); i++)
			quadruples.get(list.get(i)).result = String.valueOf(quadNumber);
	}

	private void backpatch(int quadNumber, int destination) {
		quadruples.get(quadNumber).result = String.valueOf(destination);
	}

	private String newTemp(int type, boolean array) {
		String name = tempStr + tempCounter++;
		symbolTable.addToSymbolTable(name, type, array);
		return name;
	}

	private int nextQuad() {
		return quadruples.size();
	}

	private String getTypeString(int typeCode){
		switch(typeCode){
			case EVal.TYPE_CODE_INTEGER:
				return TYPE_STRING_INTEGER;
			case EVal.TYPE_CODE_REAL:
				return TYPE_STRING_REAL;
			case EVal.TYPE_CODE_CHAR:
				return TYPE_STRING_CHAR;
			case EVal.TYPE_CODE_BOOLEAN:
				return TYPE_STRING_BOOLEAN;
			case EVal.TYPE_CODE_UNKNOWN:
			case EVal.TYPE_CODE_RANGE:
			default:
				return null;
		}
	}

	private void exportIntermediateCode() {
		DataOutputStream dos = null;
		try {
			dos = new DataOutputStream(new FileOutputStream(fileAddress));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		try {
			dos.writeBytes("#include <stdio.h>\n\nint main() {\n\t// ////////////////// Symbol Table \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\n\n");
			dos.writeBytes(symbolTable.toString());
			dos.writeBytes("\n\t// ////////////////// Quadruples \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\n\n");
			// Backpatch of error controllers.
			backpatch(EVal.arrayIndexOutOfBoundList, (quadruples.size() + 1)); // Array index out of bound error.
			backpatch(EVal.invalidArraySizeList, (quadruples.size() + 2)); // Invalid array size error.
			for (int i = 0; i < quadruples.size() && i < 100; i++) {
				dos.writeBytes(Quadruple.LINE_STR + i + ":" + "\t\t" + quadruples.get(i) + "\n");
			}
			for (int i = 100; i < quadruples.size(); i++) {
				dos.writeBytes(Quadruple.LINE_STR + i + ":" + "\t\t" + quadruples.get(i) + "\n");
			}
			// Normal Finish
			if(quadruples.size() < 100)
				dos.writeBytes(Quadruple.LINE_STR + quadruples.size() + ":" + "\t\tprintf(\"Process is terminated with no error.\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\t\treturn 0;\n");
			else
				dos.writeBytes(Quadruple.LINE_STR + quadruples.size() + ":" + "\t\tprintf(\"Process is terminated with no error.\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\t\treturn 0;\n");

			// Array index out of bound error.
			if(quadruples.size() < 100)
				dos.writeBytes(Quadruple.LINE_STR + (quadruples.size() + 1) + ":" + "\t\tprintf(\"Array Error: Index out of bound!\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\treturn -1;\n");
			else
				dos.writeBytes(Quadruple.LINE_STR + (quadruples.size() + 1) + ":" + "\t\tprintf(\"Array Error: Index out of bound!\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\treturn -1;\n");

			// Invalid array size error.
			if(quadruples.size() < 100)
				dos.writeBytes(Quadruple.LINE_STR + (quadruples.size() + 2) + ":" + "\t\tprintf(\"Array Error: Invalid array size!\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\treturn -2;\n");
			else
				dos.writeBytes(Quadruple.LINE_STR + (quadruples.size() + 2) + ":" + "\t\tprintf(\"Array Error: Invalid array size!\\n\");\n" +
					"\t\t\t\tgetchar();\n\t\t\treturn -2;\n");

			dos.writeBytes("}\n");
		} catch (IOException e) {
			e.printStackTrace();
		}

	}
}

%left OR_KW OR_ELSE_KW
%right ASS_KW
%left AND_KW AND_THEN_KW
%left EQ_KW NE_KW LE_KW LT_KW GE_KW GT_KW
%left ADD_KW SUB_KW
%left MUL_KW DIV_KW MOD_KW
%right NOT_KW usub

%%
program:
	PROGRAM_KW saved_identifier declarations_list procedure_list MAIN_KW block {
		System.out.println("Rule 1.1: " +
			"program: PROGRAM_KW saved_identifier declarations_list procedure_list MAIN_KW block");
		backpatch($6.nextList, nextQuad());
		exportIntermediateCode();
	}
	| PROGRAM_KW saved_identifier procedure_list MAIN_KW block {
		System.out.println("Rule 1.2: " +
			"program: PROGRAM_KW saved_identifier procedure_list MAIN_KW block");
		backpatch($5.nextList, nextQuad());
		exportIntermediateCode();
	}
	| PROGRAM_KW saved_identifier declarations_list MAIN_KW block {
		System.out.println("Rule 1.3: " +
			"program: PROGRAM_KW saved_identifier declarations_list MAIN_KW block");
		backpatch($5.nextList, nextQuad());
		exportIntermediateCode();
	}
	| PROGRAM_KW saved_identifier MAIN_KW block {
		System.out.println("Rule 1.4: " +
			"program: PROGRAM_KW saved_identifier MAIN_KW block");
		backpatch($4.nextList, nextQuad());
		exportIntermediateCode();
	}

declarations_list:
	declarations_list declarations {
		System.out.println("Rule 2.1: " +
			"declarations_list: declarations_list declarations");
	}
	| declarations{
		System.out.println("Rule 2.2: " +
			"declarations_list: declarations");
	}

declarations:
	type_specifiers declarator_list {
		System.out.println("Rule 3: " +
			"declarations: type_specifiers declarator_list");
		if($2.type == EVal.TYPE_CODE_UNKNOWN || $1.type == $2.type) {
			for(int i = 0; i < $2.initializersList.size(); i++) {
				if(symbolTable.lookUp(sizeStr + $2.declareds.get(i).place) == SymbolTable.NOT_IN_SYMBOL_TABLE) {
					symbolTable.addToSymbolTable($2.declareds.get(i).place, $1.type, false);
					if($2.initializersList.get(i) != null && $2.initializersList.get(i).size() == 1) {
						//if($1.type != EVal.TYPE_CODE_BOOLEAN) {
							emit(":=", $2.initializersList.get(i).get(0).place, null, $2.declareds.get(i).place);
							switch ($1.type) {
								case EVal.TYPE_CODE_INTEGER:
									emit("iprint", null, null, $2.declareds.get(i).place);
									break;
								case EVal.TYPE_CODE_REAL:
									emit("rprint", null, null, $2.declareds.get(i).place);
									break;
								case EVal.TYPE_CODE_CHAR:
									emit("cprint", null, null, $2.declareds.get(i).place);
									break;
							}
						//} else {
							// backpatch($2.initializersList.get(i).get(0).falseList, nextQuad());
							// backpatch($2.initializersList.get(i).get(0).trueList, nextQuad() + 2);
						//	emit(":=", "0", null, $2.declareds.get(i).place);
						//	emit("goto", null, null, String.valueOf(nextQuad() + 2));
						//	emit(":=", "1", null, $2.declareds.get(i).place);
						//	emit("bprint", null, null, $2.declareds.get(i).place);
						//}
					} else if($2.initializersList.get(i) != null) {
						System.err.println("Error! Initializer number mismatch. (Expected: 1" + ", Number: " + $2.initializersList.get(i).size() + ")");
						return YYABORT;
					}
				} else {
					symbolTable.addToSymbolTable($2.declareds.get(i).place, $1.type, true);
					emit("malloc", getTypeString($1.type), sizeStr + $2.declareds.get(i).place, $2.declareds.get(i).place);
					if($2.initializersList.get(i) != null) {
						for(int j = 0; j < $2.initializersList.get(i).size(); j++) {
							EVal.arrayIndexOutOfBoundList.add(nextQuad() + 1);
							emit(">=", String.valueOf(j), sizeStr + $2.declareds.get(i).place, condStr + $2.declareds.get(i).place);
							emit("check", condStr + $2.declareds.get(i).place, null, String.valueOf(nextQuad() + 2)); // Result will be backpatched.
							//if($1.type != EVal.TYPE_CODE_BOOLEAN) {
								emit("[]=", $2.initializersList.get(i).get(j).place, String.valueOf(j), $2.declareds.get(i).place);
								emit("+", startStr + $2.declareds.get(i).place, String.valueOf(j), condStr + $2.declareds.get(i).place);
								switch ($1.type) {
									case EVal.TYPE_CODE_INTEGER:
										emit("aiprint", condStr + $2.declareds.get(i).place, String.valueOf(j), $2.declareds.get(i).place);
										break;
									case EVal.TYPE_CODE_REAL:
										emit("arprint", condStr + $2.declareds.get(i).place, String.valueOf(j), $2.declareds.get(i).place);
										break;
									case EVal.TYPE_CODE_CHAR:
										emit("acprint", condStr + $2.declareds.get(i).place, String.valueOf(j), $2.declareds.get(i).place);
										break;
								}
							//} else {
								// backpatch($2.initializersList.get(i).get(j).falseList, nextQuad());
								// backpatch($2.initializersList.get(i).get(j).trueList, nextQuad() + 2);
							//	emit("[]=", "0", String.valueOf(j), $2.declareds.get(i).place);
							//	emit("goto", null, null, String.valueOf(nextQuad() + 2));
							//	emit("[]=", "1", String.valueOf(j), $2.declareds.get(i).place);
							//	emit("abprint", condStr + $2.declareds.get(i).place, String.valueOf(j), $2.declareds.get(i).place);
							//}
						}
					}
				}
			}
		} else {
			System.err.println("Error! Type specifier type mismatch. (" + $1.type + ", " + $2.type + ")");
			return YYABORT;
		}
	}

type_specifiers:
	INTEGER_KW {
		System.out.println("Rule 4.1: " +
			"type_specifiers: INTEGER_KW");
		$$ = new EVal();
		((EVal)$$).type = EVal.TYPE_CODE_INTEGER;
	}
	| REAL_KW {
		System.out.println("Rule 4.2: " +
			"type_specifiers: REAL_KW");
		$$ = new EVal();
		((EVal)$$).type = EVal.TYPE_CODE_REAL;
	}
	| CHAR_KW {
		System.out.println("Rule 4.3: " +
			"type_specifiers: CHAR_KW");
		$$ = new EVal();
		((EVal)$$).type = EVal.TYPE_CODE_CHAR;
	}
	| BOOLEAN_KW {
		System.out.println("Rule 4.4: " +
			"type_specifiers: BOOLEAN_KW");
		$$ = new EVal();
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
	}

declarator_list:
	declarator_list declarator {
		System.out.println("Rule 5.1: " +
			"declarator_list: declarator_list declarator");
		if($1.type == EVal.TYPE_CODE_UNKNOWN
			|| $1.type == $2.type) {
			$$ = new EVal();
			((EVal)$$).type = $2.type;
			((EVal)$$).declareds = $1.declareds;
			((EVal)$$).declareds.add($2);
			((EVal)$$).initializersList = $1.initializersList;
			((EVal)$$).initializersList.add($2.initializers);
		} else {
			System.err.println("Error! Declarator type mismatch.");
			return YYABORT;
		}
	}
	| declarator_end {
		System.out.println("Rule 5.2: " +
			"delarator_list: declarator_end");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).declareds = EVal.makeInitializersOrDeclareds($1);
		((EVal)$$).initializersList = EVal.makeInitializersList($1.initializers);
	}

declarator:
	dec COMMA_KW {
		System.out.println("Rule 6.1: " +
			"declarator: dec COMMA_KW");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = EVal.TYPE_CODE_UNKNOWN;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = null;
	}
	| dec ASS_KW initializer {
		System.out.println("Rule 6.2: " +
			"declarator: dec ASS_KW initializer");
		if($1.array != $3.array) {
			System.err.println("Error! Array mismatch: " + $1.place + " and " + $3.place + " are not the same.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $3.type;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = $3.initializers;
	}

declarator_end:
	dec SEMICOLON_KW {
		System.out.println("Rule 7.1: " +
			"declarator_end: dec SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = EVal.TYPE_CODE_UNKNOWN;
		((EVal)$$).initializers = null;
	}
	| dec ASS_KW initializer SEMICOLON_KW {
		System.out.println("Rule 7.2: " +
			"declarator_end: dec ASS_KW initializer SEMICOLON_KW");
		if($1.array != $3.array) {
			System.err.println("Error! Array mismatch: " + $1.place + " and " + $3.place + " are not the same.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $3.type;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = $3.initializers;
	}
	| dec ASS_KW initializer_end {
		System.out.println("Rule 7.3: " +
			"declarator_end: dec ASS_KW initializer_end");
		if($1.array != $3.array) {
			System.err.println("Error! Array mismatch: " + $1.place + " and " + $3.place + " are not the same.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $3.type;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = $3.initializers;
	}

dec:
	saved_identifier {
		System.out.println("Rule 8.1: " +
			"dec: saved_identifier");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).array = false;
	}
	| saved_identifier LB_KW range RB_KW{
		System.out.println("Rule 8.2: " +
			"dec: saved_identifier LB_KW range RB_KW");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).array = true;

		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", startStr + $3.place, null , startStr + ((EVal)$$).place);

		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", sizeStr + $3.place, null , sizeStr + ((EVal)$$).place);

		symbolTable.addToSymbolTable(indexStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
	}
	| saved_identifier LB_KW saved_integer RB_KW{
		System.out.println("Rule 8.3: " +
			"dec: saved_identifier LB_KW saved_integer RB_KW");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).array = true;

		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", "0", null , startStr + ((EVal)$$).place);

		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", $3.place, null , sizeStr + ((EVal)$$).place);

		symbolTable.addToSymbolTable(indexStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
	}

range:
	saved_identifier TWO_DOTS_KW saved_identifier {
		System.out.println("Rule 9.1: " +
			"range: saved_identifier TWO_DOTS_KW saved_identifier");
		int index1 = symbolTable.lookUp($1.place);
		int index2 = symbolTable.lookUp($3.place);
		if (index1 == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $1.place + "\" is not declared.");
			return YYABORT;
		}
		if (index2 == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $3.place + "\" is not declared.");
			return YYABORT;
		}

		if(symbolTable.types.get(index1) != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $1.place + "is not integer.");
			return YYABORT;
		}
		if(symbolTable.types.get(index2) != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $3.place + "is not integer.");
			return YYABORT;
		}

		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_RANGE, true);
		((EVal)$$).type = EVal.TYPE_CODE_RANGE;
		((EVal)$$).array = true;

		// Set start and size
		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", $1.place, null , startStr + ((EVal)$$).place);
		emit("-", $3.place, $1.place , sizeStr + ((EVal)$$).place);
		emit("+", sizeStr + ((EVal)$$).place, "1", sizeStr + ((EVal)$$).place);

		// Check size
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		EVal.invalidArraySizeList.add(nextQuad() + 1);
		emit("<=", sizeStr + ((EVal)$$).place, "0", condStr + ((EVal)$$).place);
		emit("check", condStr + ((EVal)$$).place, null, String.valueOf(nextQuad() + 1));
	}
	| saved_integer TWO_DOTS_KW saved_integer {
		System.out.println("Rule 9.2: " +
			"range: saved_integer TWO_DOTS_KW saved_integer");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_RANGE, true);
		((EVal)$$).type = EVal.TYPE_CODE_RANGE;
		((EVal)$$).array = true;

		// Set start and size
		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", $1.place, null , startStr + ((EVal)$$).place);
		emit("-", $3.place, $1.place , sizeStr + ((EVal)$$).place);
		emit("+", sizeStr + ((EVal)$$).place, "1", sizeStr + ((EVal)$$).place);

		// Check size
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		EVal.invalidArraySizeList.add(nextQuad() + 1);
		emit("<=", sizeStr + ((EVal)$$).place, "0", condStr + ((EVal)$$).place);
		emit("check", condStr + ((EVal)$$).place, null, String.valueOf(nextQuad() + 1));
	}
	| arithmatic_expressions TWO_DOTS_KW arithmatic_expressions {
		System.out.println("Rule 9.3: " +
			"range: arithmatic_expressions TWO_DOTS_KW arithmatic_expressions");
		if($1.type != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $1.place + "is not integer.");
			return YYABORT;
		}
		if($3.type != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Type mismatch: " + $3.place + "is not integer.");
			return YYABORT;
		}

		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_RANGE, true);
		((EVal)$$).type = EVal.TYPE_CODE_RANGE;
		((EVal)$$).array = true;

		// Set start and size
		symbolTable.addToSymbolTable(startStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		symbolTable.addToSymbolTable(sizeStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		emit(":=", $1.place, null , startStr + ((EVal)$$).place);
		emit("-", $3.place, $1.place , sizeStr + ((EVal)$$).place);
		emit("+", sizeStr + ((EVal)$$).place, "1", sizeStr + ((EVal)$$).place);

		// Check size
		symbolTable.addToSymbolTable(condStr + ((EVal)$$).place, EVal.TYPE_CODE_INTEGER, false);
		EVal.invalidArraySizeList.add(nextQuad() + 1);
		emit("<=", sizeStr + ((EVal)$$).place, "0", condStr + ((EVal)$$).place);
		emit("check", condStr + ((EVal)$$).place, null, String.valueOf(nextQuad() + 1));
	}

initializer:
	LCB_KW initializer_list_in_cb {
		System.out.println("Rule 10.1: " +
			"initializer: LCB_KW initializer_list_in_cb");
		$$ = new EVal();
		((EVal)$$).type = $2.type;
		((EVal)$$).array = $2.array;
		((EVal)$$).initializers = $2.initializers;
	}
	| initializer_list {
		System.out.println("Rule 10.2: " +
			"initializer: initializer_list");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).array = $1.array;
		((EVal)$$).initializers = $1.initializers;
	}

initializer_list_in_cb:
	initializer_list initer RCB_KW {
		System.out.println("Rule 11.1: " +
			"initializer_list_in_cb: initializer_list constant_expressions RCB_KW");
		if($1.type == $2.type) {
			$$ = new EVal();
			((EVal)$$).type = $1.type;
			((EVal)$$).array = true;
			((EVal)$$).initializers = $1.initializers;
			((EVal)$$).initializers.add($2);
		} else {
			System.err.println("Error! " + "Initializer type mismatch.");
			return YYABORT;
		}
	}
	| initer RCB_KW {
		System.out.println("Rule 11.2: " +
			"initializer_list_in_cb: constant_expressions RCB_KW");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).array = true;
		((EVal)$$).initializers = EVal.makeInitializersOrDeclareds($1);
	}

initializer_list:
	initializer_list initer COMMA_KW {
		System.out.println("Rule 12.1: " +
			"initializer_list: initializer_list constant_expressions COMMA_KW");
		if($1.type == $2.type) {
			$$ = new EVal();
			((EVal)$$).type = $1.type;
			((EVal)$$).array = true;
			((EVal)$$).initializers = $1.initializers;
			((EVal)$$).initializers.add($2);
		} else {
			System.err.println("Error! Initializer type mismatch.");
			return YYABORT;
		}
	}
	| initer COMMA_KW {
		System.out.println("Rule 12.2: " +
			"initializer_list: constant_expressions COMMA_KW");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).array = false;
		((EVal)$$).initializers = EVal.makeInitializersOrDeclareds($1);
	}

initializer_end:
	initializer_list initer SEMICOLON_KW {
		System.out.println("Rule 13.1: " +
			"initializer_end: initializer_list constant_expressions SEMICOLON_KW");
		if($1.type == $2.type) {
			$$ = new EVal();
			((EVal)$$).type = $1.type;
			((EVal)$$).array = true;
			((EVal)$$).initializers = $1.initializers;
			((EVal)$$).initializers.add($2);
		} else {
			System.err.println("Error! Initializer type mismatch.");
			return YYABORT;
		}
	}
	| initer SEMICOLON_KW {
		System.out.println("Rule 13.2: " +
			"initializer_end: constant_expressions SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).type = $1.type;
		((EVal)$$).array = false;
		((EVal)$$).initializers = EVal.makeInitializersOrDeclareds($1);
	}

initer:
	constant_expressions {
		System.out.println("Rule 14.1: " +
			"initer: constant_expressions");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).nextList = $1.nextList;
	}
	| SUB_KW constant_expressions {
		System.out.println("Rule 14.2: " +
			"initer: SUB_KW constant_expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp($2.type, false);
		((EVal)$$).type = $2.type;
		emit("usub", $2.place, null, ((EVal)$$).place);
	}

procedure_list:
	procedure {
		System.out.println("Rule 14.1: " +
			"procedure_list: procedure");
	}
	| procedure_list procedure {
		System.out.println("Rule 14.2: " +
			"procedure_list: procedure_list procedure");
	}

procedure:
	PROCEDURE_KW saved_identifier parameters LCB_KW declarations_list block RCB_KW {
		System.out.println("Rule 15.1: " +
			"procedure: PROCEDURE_KW saved_identifier parameters LCB_KW declarations_list block RCB_KW");
	}
	| PROCEDURE_KW saved_identifier parameters LCB_KW block RCB_KW {
		System.out.println("Rule 15.2: " +
			"procedure: PROCEDURE_KW saved_identifier parameters LCB_KW block RCB_KW");
	}

parameters:
	LP_KW declarations_list RP_KW {
		System.out.println("Rule 16.1: " +
			"parameters: LP_KW declarations_list RP_KW");
	}
	| LP_KW RP_KW {
		System.out.println("Rule 16.2: " +
			"parameters: LP_KW RP_KW");
	}

block:
	LCB_KW statement_list RCB_KW {
		System.out.println("Rule 17.1: " +
			"block: LCB_KW statement_list RCB_KW");
		$$ = new EVal();
		((EVal)$$).nextList = $2.nextList;
	}
	| LCB_KW RCB_KW {
		System.out.println("Rule 17.2: " +
			"block: LCB_KW RCB_KW ");
		$$ = new EVal();
		((EVal)$$).nextList = EVal.makeList(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched
	}

statement_list:
	SEMICOLON_KW M {
		System.out.println("Rule 18.1: " +
			"statement_list: SEMICOLON_KW M");
		$$ = new EVal();
		((EVal)$$).nextList = EVal.makeList($2.quad);
	}
	| statement SEMICOLON_KW M {
		System.out.println("Rule 18.2: " +
			"statement_list: statement SEMICOLON_KW M");
		$$ = new EVal();
		((EVal)$$).nextList = $1.nextList;
	}
	| statement_list M statement SEMICOLON_KW {
		System.out.println("Rule 18.3: " +
			"statement_list: statement_list M statement SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).nextList = $3.nextList;
		backpatch($1.nextList, $2.quad);
	}

statement:
	matched{
		System.out.println("Rule 19.1: " +
			"statement: matched");
	}
	| unmatched{
		System.out.println("Rule 19.2: " +
			"statement: unmatched");
	}

matched:
	IF_KW bool_expressions THEN_KW M matched N ELSE_KW M matched {
		System.out.println("Rule 20.1: " +
			"matched: IF_KW bool_expressions THEN_KW M matched N ELSE_KW M matched");
		$$ = new EVal();
		backpatch($2.trueList, $4.quad);
		backpatch($2.falseList, $8.quad);
		((EVal)$$).nextList = EVal.merge($5.nextList, $6.nextList);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).nextList, $9.nextList);
	}
	| other_statement {
		System.out.println("Rule 20.2: " +
			"matched: other_statement");
		$$ = new EVal();
		((EVal)$$).nextList = $1.nextList;
	}

unmatched:
	 IF_KW bool_expressions THEN_KW M matched N ELSE_KW M unmatched {
		System.out.println("Rule 21.1: " +
			"unmatched: IF_KW bool_expressions THEN_KW M matched N ELSE_KW M unmatched");
		$$ = new EVal();
		backpatch($2.trueList, $4.quad);
		backpatch($2.falseList, $8.quad);
		((EVal)$$).nextList = EVal.merge($5.nextList, $6.nextList);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).nextList, $9.nextList);
	}
	| IF_KW bool_expressions THEN_KW M statement {
		System.out.println("Rule 21.2: " +
			"unmatched: IF_KW bool_expressions THEN_KW M statement");
		$$ = new EVal();
		backpatch($2.trueList, $4.quad);
		((EVal)$$).nextList = EVal.merge($2.falseList, $5.nextList);
	}


other_statement:
	saved_identifier ASS_KW expressions {
		System.out.println("Rule 22.1: " +
			"other_statement: saved_identifier ASS_KW expressions");
		int index = symbolTable.lookUp($1.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $1.place + "\" is not declared.");
			return YYABORT;
		}
		String srcPlace = $3.place;
		if((symbolTable.types.get(index) != $3.type)
			&& !((symbolTable.types.get(index) == EVal.TYPE_CODE_INTEGER
					|| symbolTable.types.get(index) == EVal.TYPE_CODE_CHAR
					|| symbolTable.types.get(index) == EVal.TYPE_CODE_BOOLEAN)
				&& ($3.type == EVal.TYPE_CODE_INTEGER
					|| $3.type == EVal.TYPE_CODE_CHAR
					|| $3.type == EVal.TYPE_CODE_BOOLEAN))) {
			if((symbolTable.types.get(index) == EVal.TYPE_CODE_REAL)
				&& ($3.type == EVal.TYPE_CODE_INTEGER
					|| $3.type == EVal.TYPE_CODE_CHAR
					|| $3.type == EVal.TYPE_CODE_BOOLEAN)) {
				srcPlace = newTemp(EVal.TYPE_CODE_REAL, false);
				emit("cast", $3.place, TYPE_STRING_REAL, srcPlace);
			} else if((symbolTable.types.get(index) == EVal.TYPE_CODE_INTEGER
					|| symbolTable.types.get(index) == EVal.TYPE_CODE_CHAR
					|| symbolTable.types.get(index) == EVal.TYPE_CODE_BOOLEAN)
				&& ($3.type == EVal.TYPE_CODE_REAL)) {
				srcPlace = newTemp(symbolTable.types.get(index), false);
				emit("cast", $3.place, getTypeString(symbolTable.types.get(index)), srcPlace);
			} else {
				System.err.println("Error! Type mismatch: " + $1.place + ", " + $3.place);
				return YYABORT;
			}
		}
		if (symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is an array, it can not be used without index.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = symbolTable.names.get(index);
		((EVal)$$).type = symbolTable.types.get(index);
		if(symbolTable.types.get(index) != EVal.TYPE_CODE_BOOLEAN) {
			((EVal)$$).nextList = $1.nextList;
			emit(":=", srcPlace, null, $1.place);
			switch (symbolTable.types.get(index)) {
				case EVal.TYPE_CODE_INTEGER:
					emit("iprint", null, null, $1.place);
					break;
				case EVal.TYPE_CODE_REAL:
					emit("rprint", null, null, $1.place);
					break;
				case EVal.TYPE_CODE_CHAR:
					emit("cprint", null, null, $1.place);
					break;
			}
		} else {
			backpatch($3.falseList, nextQuad());
			backpatch($3.trueList, nextQuad() + 2);
			emit(":=", "0", null, ((EVal)$$).place);
			emit("goto", null, null, String.valueOf(nextQuad() + 2));
			emit(":=", "1", null, ((EVal)$$).place);
			emit("bprint", null, null, $1.place);
		}
		((EVal)$$).nextList = EVal.makeList(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| saved_identifier LB_KW expressions RB_KW ASS_KW expressions {
		System.out.println("Rule 22.2: " +
			"other_statement: saved_identifier LB_KW expressions RB_KW ASS_KW expressions");
		int index = symbolTable.lookUp($1.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $1.place + "\" is not declared.");
			return YYABORT;
		}
		String srcPlace = $6.place;
		if((symbolTable.types.get(index) != $6.type)
			&& !((symbolTable.types.get(index) == EVal.TYPE_CODE_INTEGER
					|| symbolTable.types.get(index) == EVal.TYPE_CODE_CHAR
					|| symbolTable.types.get(index) == EVal.TYPE_CODE_BOOLEAN)
				&& ($6.type == EVal.TYPE_CODE_INTEGER
					|| $6.type == EVal.TYPE_CODE_CHAR
					|| $6.type == EVal.TYPE_CODE_BOOLEAN))) {
			if((symbolTable.types.get(index) == EVal.TYPE_CODE_REAL)
				&& ($6.type == EVal.TYPE_CODE_INTEGER
					|| $6.type == EVal.TYPE_CODE_CHAR
					|| $6.type == EVal.TYPE_CODE_BOOLEAN)) {
				srcPlace = newTemp(EVal.TYPE_CODE_REAL, false);
				emit("cast", $6.place, TYPE_STRING_REAL, srcPlace);
			} else if((symbolTable.types.get(index) == EVal.TYPE_CODE_INTEGER
					|| symbolTable.types.get(index) == EVal.TYPE_CODE_CHAR
					|| symbolTable.types.get(index) == EVal.TYPE_CODE_BOOLEAN)
				&& ($6.type == EVal.TYPE_CODE_REAL)) {
				srcPlace = newTemp(symbolTable.types.get(index), false);
				emit("cast", $6.place, getTypeString(symbolTable.types.get(index)), srcPlace);
			} else {
				System.err.println("Error! Type mismatch: " + $1.place + ", " + $6.place);
				return YYABORT;
			}
		}
		if (!symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is not an array, it can not be used with index.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = symbolTable.names.get(index);
		((EVal)$$).type = $1.type;
		((EVal)$$).array = true;
		EVal.arrayIndexOutOfBoundList.add(nextQuad() + 2);
		EVal.arrayIndexOutOfBoundList.add(nextQuad() + 4);
		emit("-", $3.place, startStr + $1.place, indexStr + $1.place);
		emit(">=", indexStr + $1.place, sizeStr + $1.place, condStr + $1.place);
		emit("check", condStr + $1.place, null, String.valueOf(nextQuad() + 4)); // result will be backpatched.
		emit("<", indexStr + $1.place, "0", condStr + $1.place);
		emit("check", condStr + $1.place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		if(symbolTable.types.get(index) != EVal.TYPE_CODE_BOOLEAN) {
			emit("[]=", srcPlace, indexStr + $1.place, $1.place);
			switch (symbolTable.types.get(index)) {
				case EVal.TYPE_CODE_INTEGER:
					emit("aiprint", $3.place, indexStr + $1.place, $1.place);
					break;
				case EVal.TYPE_CODE_REAL:
					emit("arprint", $3.place, indexStr + $1.place, $1.place);
					break;
				case EVal.TYPE_CODE_CHAR:
					emit("acprint", $3.place, indexStr + $1.place, $1.place);
					break;
			}
		} else {
			backpatch($3.falseList, nextQuad());
			backpatch($3.trueList, nextQuad() + 2);
			emit("[]=", "0", indexStr + $1.place, ((EVal)$$).place);
			emit("goto", null, null, String.valueOf(nextQuad() + 2));
			emit("[]=", "1", indexStr + $1.place, ((EVal)$$).place);
			emit("abprint", $3.place, indexStr + $1.place, $1.place);
		}

		((EVal)$$).nextList = EVal.makeList(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| DO_KW M statement WHILE_KW M bool_expressions {
		System.out.println("Rule 22.3: " +
			"other_statement: DO_KW M statement WHILE_KW M bool_expressions");
		$$ = new EVal();
		((EVal)$$).nextList = $6.falseList;

		backpatch($3.nextList, $5.quad);
		backpatch($6.trueList, $2.quad);
	}
	| FOR_KW saved_identifier IN_KW range N REPEAT_KW M block {
		System.out.println("Rule 22.4: " +
			"other_statement: FOR_KW saved_identifier IN_KW range N REPEAT_KW M block");
		int index = symbolTable.lookUp($2.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + $1.place + "\" is not declared.");
			return YYABORT;
		}
		// if(symbolTable.types.get(index) != EVal.TYPE_CODE_INTEGER) {
		// 	System.err.println("Error! Type mismatch: " + $1.place + ", Integer");
		// 	return YYABORT;
		// }
		if (symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is an array, it can not be used in for initializer.");
			return YYABORT;
		}

		$$ = new EVal();

		backpatch($5.nextList, nextQuad());
		backpatch($8.nextList, nextQuad() + 5);

		emit(":=", startStr + $4.place, null, $2.place);
		emit("-", $2.place, startStr + $4.place, condStr + $4.place);
		emit("<", condStr + $4.place, sizeStr + $4.place, condStr + $4.place);
		emit("check", condStr + $4.place, null, String.valueOf($7.quad));
		emit("goto", null, null, String.valueOf(nextQuad() + 3)); // result will be backpatched;
		emit("+", $2.place, "1", $2.place);
		emit("goto", null, null, String.valueOf(nextQuad() - 5));

		((EVal)$$).nextList = EVal.makeList(nextQuad() - 3);
	}
	| SWITCH_KW expressions N caseelement default END_KW {
		System.out.println("Rule 22.5.1: " +
			"other_statement: SWITCH_KW expressions N caseelement default END_KW");
		if($3.type != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Switch expression type mismatch. (\"" + $3.place + "\" is not integer.)");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_INTEGER, false);
		((EVal)$$).nextList = EVal.merge($4.nextList, $5.nextList);

		int last = $4.falseList.size() - 1;
		backpatch($3.nextList, $4.initList.get(0));
		backpatch($4.falseList.get(last), nextQuad());
		for(int i = 0; i < $4.declareds.size() - 1; i++) {
			backpatch($4.falseList.get(i), $4.initList.get(i + 1));

			emit("=", $2.place, $4.declareds.get(i).place, ((EVal)$$).place);
			emit("check", ((EVal)$$).place, null, String.valueOf($4.trueList.get(i))); // result will not be backpatched.
		}
		emit("=", $2.place, $4.declareds.get(last).place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf($4.trueList.get(last))); // result will not be backpatched.

		emit("goto", null, null, String.valueOf($5.quad)); // result will not be backpatched.
	}
	| SWITCH_KW expressions N caseelement END_KW {
		System.out.println("Rule 22.5.2: " +
			"other_statement: SWITCH_KW expressions N caseelement END_KW");
		if($3.type != EVal.TYPE_CODE_INTEGER) {
			System.err.println("Error! Switch expression type mismatch. (\"" + $3.place + "\" is not integer.)");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_INTEGER, false);
		((EVal)$$).nextList = $4.nextList;

		int last = $4.falseList.size() - 1;
		backpatch($3.nextList, $4.initList.get(0));
		backpatch($4.falseList.get(last), nextQuad());
		for(int i = 0; i < $4.declareds.size() - 1; i++) {
			backpatch($4.falseList.get(i), $4.initList.get(i + 1));

			emit("=", $2.place, $4.declareds.get(i).place, ((EVal)$$).place);
			emit("check", ((EVal)$$).place, null, String.valueOf($4.trueList.get(i))); // result will not be backpatched.
		}
		emit("=", $2.place, $4.declareds.get(last).place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf($4.trueList.get(last))); // result will not be backpatched.

		((EVal)$$).nextList.add(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad())); // result will be backpatched.
	}
	| saved_identifier LP_KW arguments RP_KW {
		System.out.println("Rule 22.6.1: " +
			"other_statement: saved_identifier LP_KW arguments RP_KW");
	}
	| saved_identifier LP_KW RP_KW {
		System.out.println("Rule 22.6.2: " +
			"other_statement: saved_identifier LP_KW RP_KW");
	}
	| RETURN_KW expressions {
		System.out.println("Rule 22.7: " +
			"other_statement: RETURN_KW expressions");
	}
	| EXIT_KW WHEN_KW LP_KW bool_expressions RP_KW {
		System.out.println("Rule 22.8: " +
			"other_statement: EXIT_KW WHEN_KW LP_KW bool_expressions RP_KW");
	}
	| block {
		System.out.println("Rule 22.9: " +
			"other_statement: block");
	}

arguments:
	declarator_list {
		System.out.println("Rule 23: " +
			"arguments: declarator_list");
	}

caseelement:
	CASE_KW M saved_integer N COLON_KW M block SEMICOLON_KW {
		System.out.println("Rule 24.1: " +
			"caseelement: CASE_KW M saved_integer N COLON_KW M block SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).initList = EVal.makeList($2.quad); // Starting point of saving saved_integer is stored in initList;
		((EVal)$$).declareds = EVal.makeInitializersOrDeclareds($3); // saved_integer value is stored in declareds.
		((EVal)$$).falseList = $4.nextList; // If there is another init point this will be backpatched to next init point, else to test point.
		((EVal)$$).trueList = EVal.makeList($6.quad); // Starting point of block is stored in trueList;
		((EVal)$$).nextList = $7.nextList;
	}
	| caseelement CASE_KW M saved_integer N COLON_KW M block SEMICOLON_KW {
		System.out.println("Rule 24.2: " +
			"caseelement: caseelement CASE_KW M saved_integer N COLON_KW M block SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).initList = $1.initList;
		((EVal)$$).initList.add($3.quad);
		((EVal)$$).declareds = $1.declareds;
		((EVal)$$).declareds.add($4);
		((EVal)$$).falseList = EVal.merge($1.falseList, $5.nextList);
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).trueList.add($7.quad);
		((EVal)$$).nextList = EVal.merge($1.nextList, $8.nextList);
	}

default:
	DEFAULT_KW COLON_KW M block N SEMICOLON_KW {
		System.out.println("Rule 25: " +
			"default: DEFAULT_KW COLON_KW M block N SEMICOLON_KW");
		$$ = new EVal();
		((EVal)$$).quad = $3.quad;
		((EVal)$$).nextList = $5.nextList;
	}

expressions:
	constant_expressions {
		System.out.println("Rule 26.1: " +
			"expressions: constant_expressions");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).nextList = $1.nextList;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
	}
	| bool_expressions {
		System.out.println("Rule 26.2: " +
			"expressions: bool_expressions");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).nextList = $1.nextList;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
	}
	| arithmatic_expressions {
		System.out.println("Rule 26.3: " +
			"expressions: arithmatic_expressions");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).nextList = $1.nextList;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
	}
	| saved_identifier {
		System.out.println("Rule 26.4: " +
			"expressions: saved_identifier");
		int index = symbolTable.lookUp($1.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + lexIdentifier + "\" is not declared.");
			return YYABORT;
		}
		if (symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is an array, it can not be used without index.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = symbolTable.names.get(index);
		((EVal)$$).type = symbolTable.types.get(index);

		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| saved_identifier LB_KW expressions RB_KW {
		System.out.println("Rule 26.5: " +
			"expressions: saved_identifier LB_KW arithmatic_expressions RB_KW");
		int index = symbolTable.lookUp($1.place);
		if (index == SymbolTable.NOT_IN_SYMBOL_TABLE) {
			System.err.println("Error! \"" + lexIdentifier + "\" is not declared.");
			return YYABORT;
		}
		if (!symbolTable.arrays.get(index)) {
			System.err.println("Error! \"" + lexIdentifier + "\" is not an array, it can not be used with index.");
			return YYABORT;
		}
		$$ = new EVal();
		((EVal)$$).place = newTemp(symbolTable.types.get(index), false);
		((EVal)$$).type = symbolTable.types.get(index);
		EVal.arrayIndexOutOfBoundList.add(nextQuad() + 2);
		EVal.arrayIndexOutOfBoundList.add(nextQuad() + 4);
		emit("-", $3.place, startStr + $1.place, indexStr + $1.place);
		emit(">=", indexStr + $1.place, sizeStr + $1.place, condStr + $1.place);
		emit("check", condStr + $1.place, null, String.valueOf(nextQuad() + 3)); // Result will be backpatched.
		emit("<", indexStr + $1.place, "0", condStr + $1.place);
		emit("check", condStr + $1.place, null, String.valueOf(nextQuad() + 1)); // Result will be backpatched.

		emit("=[]", $1.place, indexStr + $1.place, ((EVal)$$).place);

		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); //result will be backpatched.
	}
	| LP_KW expressions RP_KW {
		System.out.println("Rule 26.6: " +
			"expressions: LP_KW expressions RP_KW");
		$$ = new EVal();
		((EVal)$$).place = $2.place;
		((EVal)$$).type = $2.type;
		((EVal)$$).nextList = $2.nextList;
		((EVal)$$).trueList = $2.trueList;
		((EVal)$$).falseList = $2.falseList;
	}

constant_expressions:
	saved_integer {
		System.out.println("Rule 27.1: " +
			"constant_expressions: saved_integer");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
		((EVal)$$).nextList = $1.nextList;
	}
	| saved_real {
		System.out.println("Rule 27.2: " +
			"constant_expressions: saved_real");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
		((EVal)$$).nextList = $1.nextList;
	}
	| saved_char {
		System.out.println("Rule 27.3: " +
			"constant_expressions: saved_char");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
		((EVal)$$).nextList = $1.nextList;
	}
	| saved_boolean {
		System.out.println("Rule 27.4: " +
			"constant_expressions: saved_boolean");
		$$ = new EVal();
		((EVal)$$).place = $1.place;
		((EVal)$$).type = $1.type;
		((EVal)$$).trueList = $1.trueList;
		((EVal)$$).falseList = $1.falseList;
		((EVal)$$).nextList = $1.nextList;
	}

bool_expressions:
	expressions LT_KW expressions {
		System.out.println("Rule 28.1: " +
			"bool_expressions: expressions LT_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit("<", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions LE_KW expressions {
		System.out.println("Rule 28.2: " +
			"bool_expressions: expressions LE_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit("<=", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions GT_KW expressions {
		System.out.println("Rule 28.3: " +
			"bool_expressions: expressions GT_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit(">", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions GE_KW expressions {
		System.out.println("Rule 28.4: " +
			"bool_expressions: expressions GE_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit(">=", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions EQ_KW expressions {
		System.out.println("Rule 28.5: " +
			"bool_expressions: expressions EQ_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit("=", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions NE_KW expressions {
		System.out.println("Rule 28.6: " +
			"bool_expressions: expressions NE_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);

		emit("<>", $1.place, $3.place, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result will be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}
	| expressions AND_KW M expressions {
		System.out.println("Rule 28.7: " +
			"bool_expressions: expressions AND_KW M expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		backpatch($1.trueList, $3.quad);
		((EVal)$$).trueList = $4.trueList;
		((EVal)$$).falseList = EVal.merge($1.falseList, $4.falseList);
	}
	| expressions OR_KW M expressions {
		System.out.println("Rule 28.8: " +
			"bool_expressions: expressions OR_KW M expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		backpatch($1.falseList, $3.quad);
		((EVal)$$).trueList = EVal.merge($1.trueList, $4.trueList);
		((EVal)$$).falseList = $4.falseList;
	}
	| expressions AND_THEN_KW M expressions {
		System.out.println("Rule 28.9: " +
			"bool_expressions: expressions AND_THEN_KW M expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;

		backpatch($1.trueList, nextQuad());
		emit(":=", "1", null, ((EVal)$$).place);
		emit("goto", null, null, String.valueOf($3.quad));
		backpatch($1.falseList, nextQuad());
		emit(":=", "0", null, ((EVal)$$).place);
		emit("goto", null, null, String.valueOf($3.quad));
		backpatch($4.trueList, nextQuad());
		backpatch($4.falseList, nextQuad());
		emit("*", ((EVal)$$).place, $4.place, ((EVal)$$).place);
		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2));// result will be backpatched
		emit("goto", null, null, String.valueOf(nextQuad() + 1));// result will be backpatched
	}
	| expressions OR_ELSE_KW M expressions {
		System.out.println("Rule 28.10: " +
			"bool_expressions: expressions OR_ELSE_KW M expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;

		backpatch($1.trueList, nextQuad());
		emit(":=", "1", null, ((EVal)$$).place);
		emit("goto", null, null, String.valueOf($3.quad));
		backpatch($1.falseList, nextQuad());
		emit(":=", "0", null, ((EVal)$$).place);
		emit("goto", null, null, String.valueOf($3.quad));
		backpatch($4.trueList, nextQuad());
		backpatch($4.falseList, nextQuad());
		emit("+", ((EVal)$$).place, $4.place, ((EVal)$$).place);
		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2));
		emit("goto", null, null, String.valueOf(nextQuad() + 1));
	}
	| NOT_KW expressions {
		System.out.println("Rule 28.11: " +
			"bool_expressions: NOT_KW expressions");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = $2.falseList;
		((EVal)$$).falseList = $2.trueList;
	}

arithmatic_expressions:
	expressions ADD_KW expressions {
		System.out.println("Rule 29.1: " +
			"arithmatic_expressions: expressions ADD_KW expressions");
		if((($1.type == EVal.TYPE_CODE_INTEGER || $1.type == EVal.TYPE_CODE_CHAR || $1.type == EVal.TYPE_CODE_BOOLEAN)
				&& ($3.type == EVal.TYPE_CODE_INTEGER || $3.type == EVal.TYPE_CODE_CHAR || $3.type == EVal.TYPE_CODE_BOOLEAN))
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("+", $1.place, $3.place, ((EVal)$$).place);
		} else if(($1.type == EVal.TYPE_CODE_INTEGER || $1.type == EVal.TYPE_CODE_CHAR || $1.type == EVal.TYPE_CODE_BOOLEAN)
			&& $3.type == EVal.TYPE_CODE_REAL) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_REAL;
			String tmp = newTemp(EVal.TYPE_CODE_REAL, false);
			emit("cast", $1.place, TYPE_STRING_REAL, tmp);
			emit("+", tmp, $3.place, ((EVal)$$).place);
		} else if($1.type == EVal.TYPE_CODE_REAL
			&& ($3.type == EVal.TYPE_CODE_INTEGER || $3.type == EVal.TYPE_CODE_CHAR || $3.type == EVal.TYPE_CODE_BOOLEAN)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_REAL;
			String tmp = newTemp(EVal.TYPE_CODE_REAL, false);
			emit("cast", $3.place, TYPE_STRING_REAL, tmp);
			emit("+", $1.place, tmp, ((EVal)$$).place);
		} else {
			System.err.println("Error! Invalid type for \"+\" operation.");
			return YYABORT;
		}

		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}
	| expressions SUB_KW expressions {
		System.out.println("Rule 29.2: " +
			"arithmatic_expressions: expressions SUB_KW expressions");
		if((($1.type == EVal.TYPE_CODE_INTEGER || $1.type == EVal.TYPE_CODE_CHAR || $1.type == EVal.TYPE_CODE_BOOLEAN)
				&& ($3.type == EVal.TYPE_CODE_INTEGER || $3.type == EVal.TYPE_CODE_CHAR || $3.type == EVal.TYPE_CODE_BOOLEAN))
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("-", $1.place, $3.place, ((EVal)$$).place);
		} else if(($1.type == EVal.TYPE_CODE_INTEGER || $1.type == EVal.TYPE_CODE_CHAR || $1.type == EVal.TYPE_CODE_BOOLEAN)
			&& $3.type == EVal.TYPE_CODE_REAL) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_REAL;
			String tmp = newTemp(EVal.TYPE_CODE_REAL, false);
			emit("cast", $1.place, TYPE_STRING_REAL, tmp);
			emit("-", tmp, $3.place, ((EVal)$$).place);
		} else if($1.type == EVal.TYPE_CODE_REAL
			&& ($3.type == EVal.TYPE_CODE_INTEGER || $3.type == EVal.TYPE_CODE_CHAR || $3.type == EVal.TYPE_CODE_BOOLEAN)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_REAL;
			String tmp = newTemp(EVal.TYPE_CODE_REAL, false);
			emit("cast", $3.place, TYPE_STRING_REAL, tmp);
			emit("-", $1.place, tmp, ((EVal)$$).place);
		} else {
			System.err.println("Error! Invalid type for \"-\" operation.");
			return YYABORT;
		}

		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}
	| expressions MUL_KW expressions {
		System.out.println("Rule 29.3: " +
			"arithmatic_expressions: expressions MUL_KW expressions");
		if((($1.type == EVal.TYPE_CODE_INTEGER || $1.type == EVal.TYPE_CODE_CHAR || $1.type == EVal.TYPE_CODE_BOOLEAN)
				&& ($3.type == EVal.TYPE_CODE_INTEGER || $3.type == EVal.TYPE_CODE_CHAR || $3.type == EVal.TYPE_CODE_BOOLEAN))
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("*", $1.place, $3.place, ((EVal)$$).place);
		} else if(($1.type == EVal.TYPE_CODE_INTEGER || $1.type == EVal.TYPE_CODE_CHAR || $1.type == EVal.TYPE_CODE_BOOLEAN)
			&& $3.type == EVal.TYPE_CODE_REAL) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_REAL;
			String tmp = newTemp(EVal.TYPE_CODE_REAL, false);
			emit("cast", $1.place, TYPE_STRING_REAL, tmp);
			emit("*", tmp, $3.place, ((EVal)$$).place);
		} else if($1.type == EVal.TYPE_CODE_REAL
			&& ($3.type == EVal.TYPE_CODE_INTEGER || $3.type == EVal.TYPE_CODE_CHAR || $3.type == EVal.TYPE_CODE_BOOLEAN)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_REAL;
			String tmp = newTemp(EVal.TYPE_CODE_REAL, false);
			emit("cast", $3.place, TYPE_STRING_REAL, tmp);
			emit("*", $1.place, tmp, ((EVal)$$).place);
		} else {
			System.err.println("Error! Invalid type for \"*\" operation.");
			return YYABORT;
		}

		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}
	| expressions DIV_KW expressions {
		System.out.println("Rule 29.4: " +
			"arithmatic_expressions: expressions DIV_KW expressions");
		if((($1.type == EVal.TYPE_CODE_INTEGER || $1.type == EVal.TYPE_CODE_CHAR || $1.type == EVal.TYPE_CODE_BOOLEAN)
				&& ($3.type == EVal.TYPE_CODE_INTEGER || $3.type == EVal.TYPE_CODE_CHAR || $3.type == EVal.TYPE_CODE_BOOLEAN))
			|| ($1.type == EVal.TYPE_CODE_REAL && $3.type == EVal.TYPE_CODE_REAL)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp($1.type, false);
			((EVal)$$).type = $1.type;
			emit("/", $1.place, $3.place, ((EVal)$$).place);
		} else if(($1.type == EVal.TYPE_CODE_INTEGER || $1.type == EVal.TYPE_CODE_CHAR || $1.type == EVal.TYPE_CODE_BOOLEAN)
			&& $3.type == EVal.TYPE_CODE_REAL) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_REAL;
			String tmp = newTemp(EVal.TYPE_CODE_REAL, false);
			emit("cast", $1.place, TYPE_STRING_REAL, tmp);
			emit("/", tmp, $3.place, ((EVal)$$).place);
		} else if($1.type == EVal.TYPE_CODE_REAL
			&& ($3.type == EVal.TYPE_CODE_INTEGER || $3.type == EVal.TYPE_CODE_CHAR || $3.type == EVal.TYPE_CODE_BOOLEAN)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_REAL;
			String tmp = newTemp(EVal.TYPE_CODE_REAL, false);
			emit("cast", $3.place, TYPE_STRING_REAL, tmp);
			emit("/", $1.place, tmp, ((EVal)$$).place);
		} else {
			System.err.println("Error! Invalid type for \"/\" operation.");
			return YYABORT;
		}

		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}
	| expressions MOD_KW expressions {
		System.out.println("Rule 29.5: " +
			"arithmatic_expressions: expressions MOD_KW expressions");
		if(($1.type == EVal.TYPE_CODE_INTEGER
				|| $1.type == EVal.TYPE_CODE_CHAR
				|| $1.type == EVal.TYPE_CODE_BOOLEAN)
			&& ($3.type == EVal.TYPE_CODE_INTEGER
				|| $3.type == EVal.TYPE_CODE_CHAR
				|| $3.type == EVal.TYPE_CODE_BOOLEAN)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_INTEGER, false);
			((EVal)$$).type = EVal.TYPE_CODE_INTEGER;
			emit("%", $1.place, $3.place, ((EVal)$$).place);
		} else if(($1.type == EVal.TYPE_CODE_INTEGER
				|| $1.type == EVal.TYPE_CODE_CHAR
				|| $1.type == EVal.TYPE_CODE_BOOLEAN)
			&& $3.type == EVal.TYPE_CODE_REAL) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_INTEGER;
			String tmp = newTemp(EVal.TYPE_CODE_INTEGER, false);
			emit("cast", $3.place, TYPE_STRING_INTEGER, tmp);
			emit("%", $1.place, tmp, ((EVal)$$).place);
		} else if($1.type == EVal.TYPE_CODE_REAL
			&& ($3.type == EVal.TYPE_CODE_INTEGER
				|| $3.type == EVal.TYPE_CODE_CHAR
				|| $3.type == EVal.TYPE_CODE_BOOLEAN)) {
			$$ = new EVal();
			((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
			((EVal)$$).type = EVal.TYPE_CODE_INTEGER;
			String tmp = newTemp(EVal.TYPE_CODE_INTEGER, false);
			emit("cast", $1.place, TYPE_STRING_INTEGER, tmp);
			emit("%", tmp, $3.place, ((EVal)$$).place);
		} else {
			System.err.println("Error! Invalid type for \"%\" operation.");
			return YYABORT;
		}

		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}
	| SUB_KW expressions %prec usub {
		System.out.println("Rule 29.6: " +
			"arithmatic_expressions: SUB_KW expressions");
		// Type cheking will not be done for this operation.
		// if($2.type == EVal.TYPE_CODE_INTEGER || $2.type == EVal.TYPE_CODE_REAL){
			$$ = new EVal();
			((EVal)$$).place = newTemp($2.type, false);
			((EVal)$$).type = $2.type;
			emit("usub", $2.place, null, ((EVal)$$).place);
		// } else {
		// 	System.err.println("Error! Invalid type for unary \"-\" operation.");
		// 	return YYABORT;
		// }

		((EVal)$$).trueList = EVal.makeList(nextQuad());
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}

saved_identifier:
	IDENTIFIER {
		System.out.println("Rule 30: " +
			"saved_identifier: IDENTIFIER");
		$$ = new EVal();
		((EVal)$$).place = lexIdentifier;
	}

saved_integer:
	INTEGER_CONSTANT {
		System.out.println("Rule 31: " +
			"saved_integer: INTEGER_CONSTANT");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_INTEGER, false);
		((EVal)$$).type = EVal.TYPE_CODE_INTEGER;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit(":=", String.valueOf(lexInt), null, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.

	}

saved_real:
	REAL_CONSTANT {
		System.out.println("Rule 32: " +
			"saved_real: REAL_CONSTANT");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_REAL, false);
		((EVal)$$).type = EVal.TYPE_CODE_REAL;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit(":=", String.valueOf(lexReal), null, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}

saved_char:
	CHAR_CONSTANT {
		System.out.println("Rule 33: " +
			"saved_char: CHAR_CONSTANT");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_CHAR, false);
		((EVal)$$).type = EVal.TYPE_CODE_CHAR;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		emit(":=", "'" + String.valueOf(lexChar) + "'", null, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}

saved_boolean:
	BOOLEAN_CONSTANT {
		System.out.println("Rule 34: " +
			"saved_boolean: BOOLEAN_CONSTANT");
		$$ = new EVal();
		((EVal)$$).place = newTemp(EVal.TYPE_CODE_BOOLEAN, false);
		((EVal)$$).type = EVal.TYPE_CODE_BOOLEAN;
		((EVal)$$).trueList = EVal.makeList(nextQuad() + 1);
		((EVal)$$).falseList = EVal.makeList(nextQuad() + 2);
		((EVal)$$).nextList = EVal.merge(((EVal)$$).trueList, ((EVal)$$).falseList);

		if(lexBoolean)
			emit(":=", "1", null, ((EVal)$$).place);
		else
			emit(":=", "0", null, ((EVal)$$).place);
		emit("check", ((EVal)$$).place, null, String.valueOf(nextQuad() + 2)); // result may be backpatched.
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result may be backpatched.
	}

M:
	{
		System.out.println("Rule 35: " +
			"M: ");
		$$ = new EVal();
		((EVal)$$).quad = nextQuad();
	}

N:
	{
		System.out.println("Rule 36: " +
			"N: ");
		$$ = new EVal();
		((EVal)$$).nextList = EVal.makeList(nextQuad());
		emit("goto", null, null, String.valueOf(nextQuad() + 1)); // result will be backpatched.
	}

%%
// Classes
// // EVal
class EVal {

	public static final int TYPE_CODE_UNKNOWN = -1;
	public static final int TYPE_CODE_INTEGER = 0;
	public static final int TYPE_CODE_REAL = 1;
	public static final int TYPE_CODE_CHAR = 2;
	public static final int TYPE_CODE_BOOLEAN = 3;
	public static final int TYPE_CODE_RANGE = 4;


	public String place;
	public int type;
	public boolean array;

	public int quad;

	public static ArrayList<Integer> arrayIndexOutOfBoundList = new ArrayList<>();
	public static ArrayList<Integer> invalidArraySizeList = new ArrayList<>();
	public ArrayList<Integer> initList;
	public ArrayList<Integer> nextList;
	public ArrayList<Integer> trueList;
	public ArrayList<Integer> falseList;

	public ArrayList<ArrayList<EVal>> initializersList;
	public ArrayList<EVal> declareds;

	public ArrayList<EVal> initializers;

	public EVal() {
	}

	public static ArrayList<Integer> makeList(int number) {
		ArrayList<Integer> result = new ArrayList<>();
		result.add(number);
		return result;
	}

	public static ArrayList<Integer> merge(ArrayList<Integer> al1, ArrayList<Integer> al2) {
		ArrayList<Integer> result = new ArrayList<>();
		result.addAll(al1);
		result.addAll(al2);
		return result;
	}

	public static ArrayList<ArrayList<EVal>> makeInitializersList(ArrayList<EVal> initializers) {
		ArrayList<ArrayList<EVal>> result = new ArrayList<>();
		result.add(initializers);
		return result;
	}

	public static ArrayList<EVal> makeInitializersOrDeclareds(EVal initializerOrdDeclared) {
		ArrayList<EVal> result = new ArrayList<>();
		result.add(initializerOrdDeclared);
		return result;
	}
}

// // Quadruple
/*  ______________________________________________________________________________
 * |                                                                              |
 * |                                  Quadruples                                  |
 * |______________________________________________________________________________|
 * |              Statement             | Operation |    Arg0   |  Arg1 |  Result |
 * |____________________________________|___________|___________|_______|_________|
 * |               goto L               |    goto   |           |       |    L    |
 * |       if BOOLEAN then goto L       |   check   |  BOOLEAN  |       |    L    |
 * |             E = E1 < E2            |     <     |     E1    |   E2  |    E    |
 * |            E = E1 <= E2            |     <=    |     E1    |   E2  |    E    |
 * |             E = E1 > E2            |     >     |     E1    |   E2  |    E    |
 * |            E = E1 >= E2            |     >=    |     E1    |   E2  |    E    |
 * |            E = E1 == E2            |     =     |     E1    |   E2  |    E    |
 * |            E = E1 <> E2            |     <>    |     E1    |   E2  |    E    |
 * |             E = E1 + E2            |     +     |     E1    |   E2  |    E    |
 * |             E = E1 - E2            |     -     |     E1    |   E2  |    E    |
 * |             E = E1 * E2            |     *     |     E1    |   E2  |    E    |
 * |             E = E1 / E2            |     /     |     E1    |   E2  |    E    |
 * |             E = E1 % E2            |     %     |     E1    |   E2  |    E    |
 * |               E = -E1              |    usub   |     E1    |       |    E    |
 * |               E = E1               |     :=    |     E1    |       |    E    |
 * |            E = (TYPE) E1           |    cast   |     E1    |  TYPE |    E    |
 * |               TYPE E               |    init   |           |  TYPE |    E    |
 * |         printf("E = E.val")        |   iprint  |           |       |   int   |
 * |         printf("E = E.val")        |   rprint  |           |       |   real  |
 * |         printf("E = E.val")        |   cprint  |           |       |   char  |
 * |         printf("E = E.val")        |   bprint  |           |       | boolean |
 * |  printf("E[PLACE] = E[INDEX].val") |  aiprint  |   PLACE   | INDEX |   int   |
 * |  printf("E[PLACE] = E[INDEX].val") |  arprint  |   PLACE   | INDEX |   real  |
 * |  printf("E[PLACE] = E[INDEX].val") |  acprint  |   PLACE   | INDEX |   char  |
 * |  printf("E[PLACE] = E[INDEX].val") |  abprint  |   PLACE   | INDEX | boolean |
 * | NAME = malloc(sizeOf(TYPE) * SIZE) |   malloc  |    TYPE   |  SIZE |   NAME  |
 * |          *(E + INDEX) = E1         |    []=    |     E1    | INDEX |    E    |
 * |          E = *(E1 + INDEX)         |    =[]    |     E1    | INDEX |    E    |
 * |____________________________________|___________|___________|_______|_________|
 */
class Quadruple {

	public static final String LINE_STR = "Line";

	public String operation;
	public String arg0;
	public String arg1;
	public String result;

	public Quadruple(String operation, String arg0, String arg1, String result) {
		this.operation = operation;
		this.arg0 = arg0;
		this.arg1 = arg1;
		this.result = result;
	}

	@Override
	public String toString() {
		switch(operation.toLowerCase()){
			case "goto":
				return operation + " " + LINE_STR + result + ";";
			case "check":
				return "if (" + arg0 + ") goto " + LINE_STR + result + ";";
			case "<":
			case "<=":
			case ">":
			case ">=":
			case "+":
			case "-":
			case "*":
			case "/":
			case "%":
				return result + " = " + arg0 + " " + operation + " " + arg1 + ";";
			case "=":
				return result + " = " + arg0 + " " + "==" + " " + arg1 + ";";
			case "<>":
				return result + " != " + arg0 + " " + "==" + " " + arg1 + ";";
			case "usub":
				return result + " = -" + arg0 + ";";
			case ":=":
				return result + " = " + arg0 + ";";
			case "cast":
				return result + " = (" + arg1 + ") " + arg0 + ";";
			case "init":
				return arg1 + " " + result + ";";
			case "iprint":
				return "printf(\"%s = %d\\n\", \"" + result + "\", " + result + ");";
			case "rprint":
				return "printf(\"%s = %f\\n\", \"" + result + "\", " + result + ");";
			case "cprint":
				return "printf(\"%s = '%c'\\n\", \"" + result + "\", " + result + ");";
			case "bprint":
				return "printf(\"%s = %s\\n\", \"" + result + "\", " + result + " ? \"true\" : \"false\");";
			case "aiprint":
				return "printf(\"%s[%d] = %d\\n\", \"" + result + "\", " + arg0 + ", " + result + "[" + arg1 + "]);";
			case "arprint":
				return "printf(\"%s[%d] = %f\\n\", \"" + result + "\", " + arg0 + ", " + result + "[" + arg1 + "]);";
			case "acprint":
				return "printf(\"%s[%d] = '%c'\\n\", \"" + result + "\", " + arg0 + ", " + result + "[" + arg1 + "]);";
			case "abprint":
				return "printf(\"%s[%d] = %s\\n\", \"" + result + "\", " + arg0 + ", " + result + "[" + arg1 + "] ? \"true\" : \"false\");";
			case "[]=":
				return "*(" + result + " + " + arg1 + ") = " + arg0 + ";";
			case "=[]":
				return result + " = *(" + arg0 + " + " + arg1 + ");";
			case "malloc":
				return result + " = " + "malloc(sizeof(" + arg0 + ") * " + arg1+ ");";
			default:
				return null;
		}
	}
}

// Symbol Table
class SymbolTable {

	public static final int NOT_IN_SYMBOL_TABLE = -1;

	public ArrayList<String> names;
	public ArrayList<Integer> types;
	public ArrayList<Boolean> arrays;

	public SymbolTable() {
		names = new ArrayList<>();
		types = new ArrayList<>();
		arrays = new ArrayList<>();
	}

	public int lookUp(String name) {
		return names.indexOf(name);
	}

	public boolean addToSymbolTable(String name, int type, boolean array) {
		if (lookUp(name) == -1) {
			names.add(name);
			types.add(type);
			arrays.add(array);
			return true;
		}
		return false;
	}

	@Override
    public String toString() {
        if(names.size() == 0)
            return null;
        String res = "";
        for(int i = 0; i < names.size(); i++) {
            switch (types.get(i)) {
                case EVal.TYPE_CODE_INTEGER:
                    res += "\t" + YYParser.TYPE_STRING_INTEGER;
                    break;
                case EVal.TYPE_CODE_REAL:
                    res += "\t" + YYParser.TYPE_STRING_REAL;
                    break;
                case EVal.TYPE_CODE_CHAR:
                    res += "\t" + YYParser.TYPE_STRING_CHAR;
                    break;
                case EVal.TYPE_CODE_BOOLEAN:
                    res += "\t" + YYParser.TYPE_STRING_BOOLEAN;
                    break;
                case EVal.TYPE_CODE_RANGE:
                    continue;
            }
            res += (arrays.get(i) ? " *" : " ") + names.get(i) + ";\n";
        }
        return res;
	}

}
